"""pypickle is to save and load variables from pickle files.

Name        : pypickle.py
Author      : E.Taskesen
Contact     : erdogant@gmail.com
Github      : https://github.com/erdogant/pypickle
Licence     : See licences

"""

import pickle
import os
import re
import logging
import builtins
from typing import Union

logger = logging.getLogger(__name__)

# %% Save pickle file
def save(filepath: str, var, overwrite: bool = False, fix_imports: bool = True, verbose: int = 20):
    """Save pickle file for input variables.

    Parameters
    ----------
    filepath : str
        Pathname to store pickle files.
    var : {list, object, dataframe, etc}
        Name of list or dict or anything else that needs to be stored.
    fix_imports : bool, (default=True)
        fix_imports are used for compatibility support for pickle stream generated by Python 2. If fix_imports is true, pickle will try to map the old Python 2 names to the new names used in Python 3.
    overwrite : bool, (default=False)
        Overwite file if exists.
    verbose : int, (default: 20)
        Print progress to screen. The default is 20.
        10:Debug, 20:Info, 30:Warn 40:Error, 60 or 0:Silent

    Returns
    -------
    Status of succes : bool [True,False].

    Example
    -------
    >>> import pypickle
    >>> filepath = './temp/test.pkl'
    >>> data = [1,2,3,4,5]
    >>> status = pypickle.save(filepath, data)

    """
    # Set logger
    set_logger(verbose)
    # Make empty pickle file
    if os.path.isdir(filepath):
        logger.info(f'Filepath {filepath} should be a file with a path and not directory.')
        return False
    if os.path.isfile(filepath) and not overwrite:
        logger.info(f'File already exists and is not overwritten: {filepath}')
        return False

    outfile = open(filepath, 'wb')
    # Write and close
    pickle.dump(var, outfile)
    outfile.close()

    if os.path.isfile(filepath):
        logger.info(f'Pickle file saved: {filepath}')
        out = True
    else:
        logger.info(f'Pickle file could not be saved: {filepath}')
    return out

# %% Load pickle file
def load(filepath: str,
         fix_imports: bool = True,
         encoding: str = "ASCII",
         errors: str = "strict",
         safe: Union[bool, dict] = True,
         verbose: str = 'info',
         ):
    """
    Load a pickle file from disk, with optional security restrictions.

    Parameters
    ----------
    filepath : str
        Path to the pickle file.
    fix_imports : bool, default=True
        Compatibility option for loading Python 2 pickles in Python 3.
    encoding : str, default="ASCII"
        Encoding for loading legacy Python 2 pickles.
    errors : str, default="strict"
        Error handling strategy for decoding.
    safe : bool or dict, default=True
        - True: Use safe unpickler with restricted modules.
        - False: Use standard pickle.load (unsafe).
        - dict: Use safe unpickler and allow additional custom modules.
    verbose : str, default='info'
        Verbosity level for logging.

    Returns
    -------
    object
        The deserialized Python object from the pickle file.

    Examples
    --------
    >>> import pypickle
    >>> filepath = 'mydata.pkl'
    >>> data = [1, 2, 3]
    >>> pypickle.save(filepath, data)
    >>> # Load safely (default)
    >>> data = pypickle.load(filepath)
    >>> data = pypickle.load(filepath, safe=False)

    >>> # Load with custom safe module
    >>> data = pypickle.load(filepath, safe={'my_custom_module': {'MyClass'}})

    >>> # Load unsafely (not recommended)
    >>> data = pypickle.load(filepath, safe=False)

    >>> # Load unsafely exploit that start calculator
    >>> data = pypickle.load(r'D:\REPOS\pypickle\tests/malicious.pkl')

    """
    out = None
    if os.path.isfile(filepath):
        # logger.info(f"Pickle file loaded: {filepath}")
        if isinstance(safe, dict) or safe is True:
            user_modules = safe if isinstance(safe, dict) else {}
            out = load_safe(filepath, user_modules)
        else:
            out = load_unsafe(filepath, fix_imports, encoding, errors)
    else:
        logger.info(f'Pickle file does not exist: {filepath}')

    return out


# %%
def load_safe(filepath, safe_modules={}):
    """Load pickle file securely with error handling."""
    logger.info(f"Pickle file loaded (safe): {filepath}")
    try:
        with open(filepath, "rb") as f:
            return SafeUnpickler(f, safe_modules).load()
    except pickle.UnpicklingError as e:
        logger.error(f"UnpicklingError: The file may be unsafe or corrupted.\nDetails: {e}")
    except (AttributeError, ModuleNotFoundError, EOFError, ImportError) as e:
        logger.error(f"Pickle loading failed: {e.__class__.__name__}: {e}")
    except Exception as e:
        logger.exception("An unexpected error occurred while loading the pickle file.")
    return None


def load_unsafe(filepath, fix_imports, encoding, errors):
    """Load a pickle file without restrictions (not safe)."""
    logger.info(f"Pickle file loaded (unsafe): {filepath}")
    with open(filepath, "rb") as f:
        return pickle.load(f, fix_imports=fix_imports, encoding=encoding, errors=errors)


# %%
class SafeUnpickler(pickle.Unpickler):
    """Restricted unpickler that prevents arbitrary code execution."""

    allowed_builtins = {
        'range', 'complex', 'set', 'frozenset', 'slice',
        'dict', 'list', 'tuple', 'str', 'int', 'float', 'bool',
        'bytes', 'bytearray', 'NoneType', 'object',
    }

    def __init__(self, file, safe_modules=None):
        super().__init__(file)
        if safe_modules is None:
            safe_modules = {}

        self.allowed_modules = {
            'builtins': self.allowed_builtins,
            'collections': {'OrderedDict', 'defaultdict', 'deque'},
            'datetime': {'datetime', 'date', 'time', 'timedelta'},
            'types': {'SimpleNamespace'},
            **safe_modules
        }

    def find_class(self, module, name):
        # This is used internally by the pickle.Unpickler class during the unpickling process.
        if module in self.allowed_modules and name in self.allowed_modules[module]:
            if module == "builtins":
                return getattr(builtins, name)
            mod = __import__(module)
            return getattr(mod, name)
        raise pickle.UnpicklingError(f"Global '{module}.{name}' is forbidden")


# %% Clean filename
def clean(filename: str) -> str:
    """Clean the filename to make sure the file can be saved on disk.

    Description
    -----------
    The following characters are replaced from the filename: '&', ',', '?', '$', '!' '/', '\' with character: '_'

    Parameters
    ----------
    filename : str
        Filename.

    Returns
    -------
    TYPE: str
        filename

    Example
    -------
    >>> import pypickle
    >>> filename = 't/st.pkl'
    >>> data = [1,2,3,4,5]
    >>> filename = pypickle.clean(filename)
    >>> # Save
    >>> status = pypickle.save(filename, data)
    >>> # Load file
    >>> data = pypickle.load(filepath)

    """
    return re.sub(r'[|&|,|?|$|!|/|\\]', r'_', filename)


# %%
def check_logger(verbose: [str, int] = 'info'):
    """Check the logger."""
    set_logger(verbose)
    logger.debug('DEBUG')
    logger.info('INFO')
    logger.warning('WARNING')
    logger.critical('CRITICAL')


# %%
def get_logger():
    """Return logger status."""
    return logger.getEffectiveLevel()


# %%
def set_logger(verbose: [str, int] = 'info'):
    """Set the logger for verbosity messages.

    Parameters
    ----------
    verbose : [str, int], default is 'info' or 20
        Set the verbose messages using string or integer values.
        * [0, 60, None, 'silent', 'off', 'no']: No message.
        * [10, 'debug']: Messages from debug level and higher.
        * [20, 'info']: Messages from info level and higher.
        * [30, 'warning']: Messages from warning level and higher.
        * [50, 'critical']: Messages from critical level and higher.

    Returns
    -------
    None.

    > # Set the logger to warning
    > set_logger(verbose='warning')
    > # Test with different messages
    > logger.debug("Hello debug")
    > logger.info("Hello info")
    > logger.warning("Hello warning")
    > logger.critical("Hello critical")

    """
    # Convert old verbose to new
    verbose = convert_verbose_to_new(verbose)
    # Set 0 and None as no messages.
    if (verbose==0) or (verbose is None):
        verbose=60
    # Convert str to levels
    if isinstance(verbose, str):
        levels = {'silent': 60,
                  'off': 60,
                  'no': 60,
                  'debug': 10,
                  'info': 20,
                  'warning': 30,
                  'error': 50,
                  'critical': 50}
        verbose = levels[verbose]

    # Show examples
    logger.setLevel(verbose)


# %%
def convert_verbose_to_new(verbose):
    """Convert old verbosity to the new."""
    # In case the new verbosity is used, convert to the old one.
    if verbose is None: verbose=0
    if not isinstance(verbose, str) and verbose < 10:
        status_map = {
            'None': 'silent',
            0: 'silent',
            6: 'silent',
            1: 'critical',
            2: 'warning',
            3: 'info',
            4: 'debug',
            5: 'debug'}
        if verbose>=2: print('[pypickle]> WARNING use the standardized verbose status. The status [1-6] will be deprecated in future versions.')
        return status_map.get(verbose, 0)
    else:
        return verbose
