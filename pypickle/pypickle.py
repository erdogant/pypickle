"""pypickle is to save and load variables from pickle files.

Name        : pypickle.py
Author      : E.Taskesen
Contact     : erdogant@gmail.com
Github      : https://github.com/erdogant/pypickle
Licence     : See licences

"""

import pickle
import os
import re
import logging
import builtins
from typing import Union, List, Set
import pickletools
from collections import defaultdict

logger = logging.getLogger(__name__)

#%%
def get_risk_modules():
    """Risk modules.
    These modules can be used for code execution, filesystem manipulation, networking, or loading arbitrary code.

    Returns
    -------
    risky_modules : dict

    """
    risk_modules = [
    'os',             # Shell access, file system, environment
    'subprocess',     # Can execute arbitrary system commands
    'sys',            # System-level operations, e.g., path, exit
    'nt',             # Windows native system calls (like os)
    'posix',          # Unix equivalent of nt
    'builtins',       # If abused (e.g., eval, exec); handled separately
    'importlib',      # Dynamic importing
    'socket',         # Network access
    'selectors',      # Low-level network/socket
    'multiprocessing',# Starts subprocesses
    'threading',      # Concurrency (can spawn dangerous threads)
    'asyncio',        # Async tasks (can be misused)
    'ctypes',         # Can load arbitrary C libraries
    'platform',       # Access system info
    'webbrowser',     # Can open URLs or trigger browser actions
    'shutil',         # File operations, disk wiping
    'tempfile',       # File system operations
    'glob',           # Can access wildcards over filesystem
    'pathlib',        # File access (safe in limited form, but still risky)
    'codecs',         # Can decode to arbitrary formats (rare exploit)
    ]
    return risk_modules

# def get_allowed_modules():
#     """Allowed modules.
#     These modules are allowed.

#     Returns
#     -------
#     list

#     """
#     allowed_modules = [
#     'builtins',         # Basic Python types and functions
#     'collections',      # e.g., defaultdict, OrderedDict
#     'datetime',         # e.g., datetime, timedelta
#     'types',            # e.g., SimpleNamespace
#     'math',             # Common math functions (sqrt, sin, etc.)
#     'decimal',          # Safer numerical precision
#     'fractions',        # Fractional arithmetic
#     're',               # Regular expressions (safe)
#     'copyreg',          # Used internally by pickle
#     'functools',        # e.g., partial, reduce
#     'operator',         # Functional ops (add, mul, etc.)
#     'itertools',        # Combinatorics
#     'pprint',           # Pretty printing (often in configs)
#     'numpy',            # Safe numerical arrays
#     'pandas',           # Tabular data handling
#     'sklearn',          # ML models (as long as no shelling)
#     'joblib',           # Often used with sklearn
#     'scipy',            # Scientific computing
#     'matplotlib',       # For serialized plots
#     'seaborn',          # Visualization
#     'statsmodels',      # Statistical models
#     'networkx',         # Graph objects
#     'graphviz',         # For exported graph pipelines
#     'pathlib',          # Filesystem paths (safe unless misused)
#     ]
#     return allowed_modules

# %% Save pickle file
def save(filepath: str, var, overwrite: bool = False, fix_imports: bool = True, verbose: int = 20):
    """Save pickle file for input variables.

    Parameters
    ----------
    filepath : str
        Pathname to store pickle files.
    var : {list, object, dataframe, etc}
        Name of list or dict or anything else that needs to be stored.
    fix_imports : bool, (default=True)
        fix_imports are used for compatibility support for pickle stream generated by Python 2. If fix_imports is true, pickle will try to map the old Python 2 names to the new names used in Python 3.
    overwrite : bool, (default=False)
        Overwite file if exists.
    verbose : int, (default: 20)
        Print progress to screen. The default is 20.
        10:Debug, 20:Info, 30:Warn 40:Error, 60 or 0:Silent

    Returns
    -------
    Status of succes : bool [True,False].

    Example
    -------
    >>> import pypickle
    >>> filepath = './temp/test.pkl'
    >>> data = [1,2,3,4,5]
    >>> status = pypickle.save(filepath, data)

    """
    # Set logger
    set_logger(verbose)

    # Make empty pickle file
    if os.path.isdir(filepath):
        logger.info(f'Filepath {filepath} should be a file with a path and not directory.')
        return False
    if os.path.isfile(filepath) and not overwrite:
        logger.info(f'File already exists and is not overwritten: {filepath}')
        return False

    outfile = open(filepath, 'wb')
    # Write and close
    pickle.dump(var, outfile)
    outfile.close()

    if os.path.isfile(filepath):
        logger.info(f'Pickle file saved: {filepath}')
        out = True
    else:
        logger.info(f'Pickle file could not be saved: {filepath}')
    return out


# %% Load Function
def load(filepath: str,
         fix_imports: bool = True,
         encoding: str = "ASCII",
         errors: str = "strict",
         validate: Union[bool, list] = True,
         verbose: str = 'info',
         ):
    """
    Load a pickle file from disk, with optional security restrictions.
    pickle files are directly loaded if all modules are in the allowlist. If the pickle file contains unknown modules, the modules needs to be validated using the validate parameter.
    pickle files that contain risky modules, i.e., those that can automatically make changes on the system or start (unwanted) applications are not allowed unless specifically specified using the validate parameter.

    | Module Type        | Allowed? | How to Change Behavior                         |
    | ------------------ | -------- | ---------------------------------------------- |
    | Unknown            | V        | Allowed unless in risky list                   |
    | Risky (`os`, etc.) | X        | Must be explicitly added via `validate=['nt']` |
    | Custom safe        | V        | If included in `validate` param                |

    Parameters
    ----------
    filepath : str
        Path to the pickle file.
    fix_imports : bool
        Compatibility for loading Python 2 pickles in Python 3.
    encoding : str
        Encoding for legacy Python 2 pickles.
    errors : str
        Error handling for decoding.
    validate : bool or list, default=True
        - True: Validate with default safe module list.
        - False: Disable all validation (use at own risk).
        - list: modules that are allowed based on name prefixes.
    verbose : str
        Verbosity level (not used here, placeholder).

    Returns
    -------
    object or None
        The loaded Python object or None if loading fails.

    Examples
    --------
    >>> # Example 1
    >>> import pypickle
    >>> filepath = 'mydata.pkl'
    >>> data = [1, 2, 3]
    >>> status = pypickle.save(filepath, data, overwrite=True)
    >>> # Load with validation (default)
    >>> data = pypickle.load(filepath)
    >>> data = pypickle.load(filepath, validate=False)
    >>> #
    >>> # Example 2
    >>> # Load without validation (not recommended)
    >>> data = pypickle.load(filepath, validate=False)
    >>> #
    >>> # Example 3
    >>> # Load without validation: exploit that start calculator
    >>> data = pypickle.load(r'malicious.pkl')
    >>> data = pypickle.load(r'malicious.pkl', validate=False)
    >>> mods = pypickle.validate_modules(r'malicious.pkl')
    >>> data = pypickle.load(r'malicious.pkl', validate=mods)
    >>> #
    >>> # Example 4
    >>> # Sklearn example
    >>> from sklearn.linear_model import LogisticRegression
    >>> model=LogisticRegression()
    >>> status = pypickle.save('model.pkl', model, overwrite=True)
    >>> pypickle.load('model.pkl', validate=False)
    >>> pypickle.load('model.pkl', validate=True)
    >>> #
    >>> # Example 5
    >>> modules_safe = pypickle.validate_modules('model.pkl')
    >>> pypickle.load('model.pkl', validate=modules_safe)
    >>> pypickle.load('model.pkl', validate='sklearn')

    """
    # Set the logger
    set_logger(verbose)
    # Check validate
    if isinstance(validate, str): validate = [validate]

    allowlist = []
    # # Check allowlist
    # if isinstance(allowlist, str) and allowlist == 'default':
    #     logger.info('Allowing default (trusted) modules.')
    #     allowlist = get_allowed_modules()
    # elif allowlist is None:
    #     allowlist = []
    # else:
    #     logger.error('Parameter <allowlist> is invalid.')
    #     return False

    # Check file
    if not os.path.isfile(filepath):
        logger.info(f'Pickle file does not exist: {filepath}')
        return None

    # Loading
    logger.info(f"Loading Pickle file: {filepath}")
    if isinstance(validate, list) or validate is True:
        # Add custom modules to the defaults
        user_modules = validate + allowlist if isinstance(validate, list) else None
        return load_and_validate(filepath, fix_imports, encoding, errors, user_modules)
    else:
        return load_pickle(filepath, fix_imports, encoding, errors)


# %% Unsafe Loader (No Validation)
def load_pickle(filepath, fix_imports=True, encoding="ASCII", errors="strict"):
    """Load a pickle file without validation."""
    with open(filepath, "rb") as f:
        return pickle.load(f, fix_imports=fix_imports, encoding=encoding, errors=errors)


# %% Secure Pickle Loader
def load_and_validate(filepath, fix_imports=True, encoding="ASCII", errors="strict", validate_modules=None):
    """
    Securely validate pickle file contents and load it only if safe.

    Parameters
    ----------
    filepath : str
        Path to the pickle file.
    validate_modules : list or None
        List of allowed module prefixes (e.g. ['sklearn', 'numpy']).
    fix_imports : bool
    encoding : str
    errors : str

    Returns
    -------
    object or None
        The unpickled object or None if loading failed or unsafe.
    """
    try:
        # 1. Validate using custom unpickler (does not return the object, only checks)
        with open(filepath, "rb") as f:
            ValidateUnpickler(f, validate_modules=validate_modules, risky_modules=get_risk_modules()).load()
        # 2. If successful, load pickle file
        return load_pickle(filepath, fix_imports, encoding, errors)

    except pickle.UnpicklingError as e:
        # logger.error(f"UnpicklingError: The modules in the pickle file are not validated or are marked as risky.")
        logger.error(f"UnpicklingError: {e}")
    except (AttributeError, ModuleNotFoundError, EOFError, ImportError) as e:
        logger.error(f"Pickle loading failed: {e.__class__.__name__}: {e}")
    except Exception as e:
        # logger.exception("An unexpected error occurred while validating the pickle file.")
        logger.error(f"UnpicklingError: {e}")
    return None


# %% Custom Unpickler
# class ValidateUnpickler(pickle.Unpickler):
#     """Restricted unpickler that prevents loading unsafe modules."""
#     # default_allowed_modules = get_allowed_modules()

#     def __init__(self, file, validate_modules=None, default_allowed_modules=get_allowed_modules()):
#         super().__init__(file)
#         self.allowed_modules = validate_modules if validate_modules else default_allowed_modules

#     def find_class(self, module, name):
#         if any(module == allowed or module.startswith(f"{allowed}.") for allowed in self.allowed_modules):
#             mod = __import__(module, fromlist=[name])
#             return getattr(mod, name)
#         raise pickle.UnpicklingError(f"Loading '{module}.{name}' is not allowed. Add to pypickle.load(..., validate=['{module}']) to load securily.")


#%%
class ValidateUnpickler(pickle.Unpickler):
    """
    Unpickler that blocks risky modules but allows user-specified modules even if they would normally be blocked.

    """
    def __init__(self, file, validate_modules=None, risky_modules=None):
        super().__init__(file)
        self.validate_modules = validate_modules if validate_modules else []
        self.risky_modules = risky_modules if risky_modules is not None else get_risk_modules()

    def find_class(self, module, name):
        # If module is explicitly validated by the user, allow it
        if any(module == allowed or module.startswith(f"{allowed}.") for allowed in self.validate_modules):
            mod = __import__(module, fromlist=[name])
            return getattr(mod, name)

        # If module is risky, block it
        if any(module == risky or module.startswith(f"{risky}.") for risky in self.risky_modules):
            raise pickle.UnpicklingError(f"[BLOCKED] Module '{module}' is considered risky. Use validate=['{module}'] to allow.")

        # Otherwise allow
        mod = __import__(module, fromlist=[name])
        return getattr(mod, name)


# %% Utility: Get list of modules in pickle
def validate_modules(filepath: str) -> list:
    """
    Extract unique module names from a pickle file.

    Parameters
    ----------
    filepath : str
        Path to the pickle file.
    warn : bool
        Print warnings for risky modules (like os, subprocess).

    Returns
    -------
    list
        List of required module name prefixes (e.g. ['sklearn', 'numpy']).
    """
    risky_modules = get_risk_modules()
    modules = set()
    stack = []

    with open(filepath, 'rb') as f:
        for opcode, arg, _ in pickletools.genops(f):
            if opcode.name in {'BINUNICODE', 'SHORT_BINUNICODE', 'UNICODE'}:
                stack.append(arg)
            elif opcode.name == 'GLOBAL' and isinstance(arg, str):
                try:
                    module, _ = arg.strip().split(' ')
                    modules.add(module)
                    if module in risky_modules:
                        logger.warning(f"[WARNING] Risky module: {module}")
                except Exception:
                    continue
            elif opcode.name == 'STACK_GLOBAL':
                if len(stack) >= 2:
                    name = stack.pop()
                    module = stack.pop()
                    modules.add(module)
                    if module in risky_modules:
                        logger.warning(f"[WARNING] Risky module: {module}.{name}")

    return sorted(modules)


# %% Clean filename
def clean(filename: str) -> str:
    """Clean the filename to make sure the file can be saved on disk.

    Description
    -----------
    The following characters are replaced from the filename: '&', ',', '?', '$', '!' '/', '\' with character: '_'

    Parameters
    ----------
    filename : str
        Filename.

    Returns
    -------
    TYPE: str
        filename

    Example
    -------
    >>> import pypickle
    >>> filename = 't/st.pkl'
    >>> data = [1,2,3,4,5]
    >>> filename = pypickle.clean(filename)
    >>> # Save
    >>> status = pypickle.save(filename, data)
    >>> # Load file
    >>> data = pypickle.load(filepath)

    """
    return re.sub(r'[|&|,|?|$|!|/|\\]', r'_', filename)


# %%
def check_logger(verbose: [str, int] = 'info'):
    """Check the logger."""
    set_logger(verbose)
    logger.debug('DEBUG')
    logger.info('INFO')
    logger.warning('WARNING')
    logger.critical('CRITICAL')


# %%
def get_logger():
    """Return logger status."""
    return logger.getEffectiveLevel()


# %%
def set_logger(verbose: [str, int] = 'info'):
    """Set the logger for verbosity messages.

    Parameters
    ----------
    verbose : [str, int], default is 'info' or 20
        Set the verbose messages using string or integer values.
        * [0, 60, None, 'silent', 'off', 'no']: No message.
        * [10, 'debug']: Messages from debug level and higher.
        * [20, 'info']: Messages from info level and higher.
        * [30, 'warning']: Messages from warning level and higher.
        * [50, 'critical']: Messages from critical level and higher.

    Returns
    -------
    None.

    > # Set the logger to warning
    > set_logger(verbose='warning')
    > # Test with different messages
    > logger.debug("Hello debug")
    > logger.info("Hello info")
    > logger.warning("Hello warning")
    > logger.critical("Hello critical")

    """
    # Convert old verbose to new
    verbose = convert_verbose_to_new(verbose)
    # Set 0 and None as no messages.
    if (verbose==0) or (verbose is None):
        verbose=60
    # Convert str to levels
    if isinstance(verbose, str):
        levels = {'silent': 60,
                  'off': 60,
                  'no': 60,
                  'debug': 10,
                  'info': 20,
                  'warning': 30,
                  'error': 50,
                  'critical': 50}
        verbose = levels[verbose]

    # Show examples
    logger.setLevel(verbose)


# %%
def convert_verbose_to_new(verbose):
    """Convert old verbosity to the new."""
    # In case the new verbosity is used, convert to the old one.
    if verbose is None: verbose=0
    if not isinstance(verbose, str) and verbose < 10:
        status_map = {
            'None': 'silent',
            0: 'silent',
            6: 'silent',
            1: 'critical',
            2: 'warning',
            3: 'info',
            4: 'debug',
            5: 'debug'}
        if verbose>=2: print('[pypickle]> WARNING use the standardized verbose status. The status [1-6] will be deprecated in future versions.')
        return status_map.get(verbose, 0)
    else:
        return verbose
