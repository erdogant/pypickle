import pypickle
import pickle
import os

class ExploitApp:
    def __reduce__(self):
        return (os.system, ("calc.exe",))  # Change to 'calc.exe' on Windows or "gnome-calculator" on Unix

class ExploitOS:
    def __reduce__(self):
        import os
        return (os.system, ("echo '[os] Exploit triggered!'",))

class ExploitSubprocess:
    def __reduce__(self):
        import subprocess
        return (subprocess.Popen, (["echo", "[subprocess] Exploit triggered!"],))

class ExploitSocket:
    def __reduce__(self):
        import socket
        return (socket.create_connection, (("example.com", 80),))

class ExploitWebBrowser:
    def __reduce__(self):
        import webbrowser
        return (webbrowser.open, ("http://example.com/malware",))

class ExploitCtypes:
    def __reduce__(self):
        import ctypes
        return (ctypes.CDLL, ("libc.so.6",))


# Choose one of the above Exploit classes
filepath = 'exploit.pkl'

status = pypickle.save(filepath, ExploitApp(), overwrite=True)
status = pypickle.save(filepath, ExploitOS(), overwrite=True)
status = pypickle.save(filepath, ExploitSubprocess(), overwrite=True)
status = pypickle.save(filepath, ExploitSocket(), overwrite=True)
status = pypickle.save(filepath, ExploitWebBrowser(), overwrite=True)
status = pypickle.save(filepath, ExploitCtypes(), overwrite=True)

# Safe load: should fail or return None
assert pypickle.load(filepath) is None

# Force load: should trigger the exploit
pypickle.load(filepath, validate=False)

# Or allow specific module
mods = pypickle.validate_modules(filepath)
pypickle.load(filepath, validate=mods)
